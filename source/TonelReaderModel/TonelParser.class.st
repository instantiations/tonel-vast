"
I'm a parser for tonel files. 
I parse a class with the following format: 

Tonel spec
====

    [comment]
    type { typeDefinition }
    (
        [{ methodMetadata }]
        method [
            methodBody ] 
    )*


comment
---
""
comment string
""
is optional (but it should be there, in good design ;)

type
---
Class|Trait|Extension

typeDefinition
---
a STON file with class/trait/extension metadata

methodMetadata
---
a STON file with method metadata
is optional (but also, recommended)

method
---
method declaration as this: 

Class[ class] >> selector

methodBody 
---
the method body (we do not parse contents, that's class builder task)
"
Class {
	#name : 'TonelParser',
	#superclass : 'Object',
	#instVars : [
		'stream'
	],
	#category : 'TonelReaderModel'
}

{
	#category : 'instance creation'
}
TonelParser class >> new [

	^super new initialize
]

{
	#category : 'instance creation'
}
TonelParser class >> on: aStream [
	^ self new
		stream: aStream;
		yourself
]

{
	#category : 'parsing'
}
TonelParser class >> parseStream: aStream [
	^ (self on: aStream) start
]

{
	#category : 'parsing'
}
TonelParser class >> parseString: aString [
	^ self parseStream: aString readStream
]

{
	#category : 'private'
}
TonelParser >> cleanSelector: aString [
	"BEWARE: I'm doing some heave assumptions here: I'm removing just ONE space (in case there 
	 is one) because I expect this to be a file generated by tonel, and tonel adds one space 
	 before start with the method body to make the format more readable. 
	 But of course this is not very good :("

	^((aString size > 1 and: [aString last = Character space])
		ifTrue: [aString allButLast]
		ifFalse: [aString])
			trimLeft: [:char | char isSeparator]
]

{
	#category : 'parsing'
}
TonelParser >> comment [
	^ (TonelCommentScanner on: stream) scan
]

{
	#category : 'parsing'
}
TonelParser >> definitionForType: aString [

	aString = TonelWriter classLabel ifTrue: [ ^ TonelReaderClassDefinition ].
	aString = TonelWriter extensionLabel ifTrue: [ ^ TonelReaderClassExtensionDefinition ].
	aString = TonelWriter packageLabel ifTrue: [ ^ TonelReaderPackageDefinition ].	
	
	TonelParseError signal: 'Unknown type declaration.'
]

{
	#category : 'parsing'
}
TonelParser >> document [

	^((Array new: 2)
		at: 1 put: self typeDef;
		at: 2 put: self methodDefList;
		yourself)
			flattened
				select: [:each | each notNil]
]

{
	#category : 'private'
}
TonelParser >> extractSelector: aString [
	| separators selectorStream keywords |
	separators := (Array new: 6)
		at: 1 put: Character space;
		at: 2 put: Character tab;
		at: 3 put: Character lf;
		at: 4 put: Character newPage;
		at: 5 put: Character cr;
		at: 6 put: $:;
		yourself.
	keywords := Array new writeStream.
	selectorStream := (self removeComments: aString) readStream.
	[ selectorStream atEnd ]
		whileFalse: [ | word ch |
			word := String new writeStream.
			[ selectorStream atEnd not
				and: [ (separators includes: (ch := selectorStream next)) not ] ]
				whileTrue: [ word nextPut: ch ].
			ch = $:
				ifTrue: [ word nextPut: ch ].
				word := word contents trimBoth: [ :char | char isSeparator ].
				word  isEmpty ifFalse: [  keywords nextPut: word ] ].
	keywords := keywords contents.
	^ (keywords size <= 2
		ifTrue: [ keywords first ]
		ifFalse:
			[ '' join: (keywords pairsCollect: [ :keyword :argument | keyword ]) ])
		asSymbol
]

{
	#category : 'private testing',
	#vaVisibility : 'private'
}
TonelParser >> isSeparator: aCharacter [
	^ aCharacter isSeparator
]

{
	#category : 'parsing'
}
TonelParser >> metadata [
	| result ch count |
	result := String new writeStream.
	count := 0.
	stream peek = ${
		ifFalse: [ TonelParseError signal: 'Can''t parse metadata' ].
	[ stream atEnd ]
		whileFalse: [ ch := stream next.
			result nextPut: ch.
			ch = ${
				ifTrue: [ count := count + 1 ].
			ch = $}
				ifTrue: [ count := count - 1 ].
			count = 0
				ifTrue: [ ^ STON fromString: result contents ] ].
	TonelParseError signal: 'Can''t parse metadata'
]

{
	#category : 'parsing'
}
TonelParser >> method [
	| type selector |
	type := self untilIncluding: '>>'.
	selector := self cleanSelector: (self untilExcluding: '[').
	type := ((type trimBoth: [ :char | char isSeparator ]) splitOn: Character space) asArray.
	type size = 1
		ifTrue: [ type := type copyWith: nil ].
	^ (Array new: 2)
		at: 1 put: type;
		at: 2 put: selector;
		yourself
]

{
	#category : 'parsing'
}
TonelParser >> methodBody [
	"I read a methodbody (what is inside [ ... ])"

	^ (TonelSourceScanner on: stream) scan
]

{
	#category : 'parsing'
}
TonelParser >> methodDef [
	^ self
		newMethodDefinitionFrom:
			((Array new: 5)
				at: 1 put: self separator;
				at: 2 put: (self try: [ self metadata ]);
				at: 3 put: self separator;
				at: 4 put: self method;
				at: 5 put: self methodBody;
				yourself)
]

{
	#category : 'parsing'
}
TonelParser >> methodDefList [
	| result |
	self separator.	"to arrive to the end of the file in case there are no methods"
	result := Array new writeStream.
	[ stream atEnd ]
		whileFalse: [ result nextPut: self methodDef.
			"skip possible spaces at the end"
			self separator ].
	^ result contents
]

{
	#category : 'private factory',
	#vaVisibility : 'private'
}
TonelParser >> newClassDefinitionFrom: anArray [

	| metadata |

	metadata := anArray at: 6.
	^((TonelReaderClassDefinition
		name: (metadata at: #name)
		superclass: (metadata at: #superclass)
		variable: nil
		fieldType: (metadata at: #type ifAbsent: ['pointers'])
		instanceVariables: (metadata at: #instVars ifAbsent: [#()])
		classVariables: (metadata at: #classVars ifAbsent: [#()])
		poolDictionaries: (metadata at: #pools ifAbsent: [#()]))
			category: (metadata at: #category);
			classInstanceVariables: (metadata at: #classInstVars ifAbsent: [#()]);
			classComment: 'this is a test';
			yourself)
]

{
	#category : 'private factory',
	#vaVisibility : 'private'
}
TonelParser >> newClassExtensionDefinitionFrom: anArray [

	| metadata |

	metadata := anArray at: 6.
	^(TonelReaderClassExtensionDefinition name: (metadata at: #name))
]

{
	#category : 'private factory',
	#vaVisibility : 'private'
}
TonelParser >> newMethodDefinitionFrom: anArray [

	| metadata className meta selector source categories visibility |

	metadata := anArray second ifNil: [Dictionary new].
	className := anArray fourth first first.
	meta := anArray fourth first second notNil.
	selector := self extractSelector: (anArray fourth second trimBoth: [:char | char isSeparator]).
	source :=
		String streamContents: [:s |
			s nextPutAll: anArray fourth second.
			(anArray at: 5) isEmpty ifFalse: [s nextPutAll: (anArray at: 5)]].
	categories :=
		metadata at: #vaCategories ifAbsent: [Array with: (metadata at: #category ifAbsent: [''])].
	visibility := metadata at: #vaVisibility ifAbsent: [nil].
	visibility :=
		visibility ifNil: [(categories includes: 'private') not] ifNotNil: [visibility = 'public'].

	^((TonelReaderMethodDefinition
		className: className
		classSide: meta
		categories: categories
		stamp: nil)
			source: source;
			selector: selector;
			visibility: visibility;
			yourself)
]

{
	#category : 'private factory',
	#vaVisibility : 'private'
}
TonelParser >> newPackageDefinitionFrom: anArray [

	| metadata |

	metadata := anArray at: 6.
	^(TonelReaderPackageDefinition fromMetadata: metadata)
]

{
	#category : 'parsing'
}
TonelParser >> newTypeDefinitionFrom: anArray [

	| typeClass |

	typeClass := self definitionForType: anArray fourth.
	typeClass = TonelReaderClassDefinition ifTrue: [^self newClassDefinitionFrom: anArray].
	typeClass = TonelReaderClassExtensionDefinition
		ifTrue: [^self newClassExtensionDefinitionFrom: anArray].
	typeClass = TonelReaderPackageDefinition ifTrue: [^self newPackageDefinitionFrom: anArray].
	self error: 'No type definition found'
]

{
	#category : 'private'
}
TonelParser >> removeComments: original [

	| newStream readStream inComment |

	newStream := original copy writeStream.
	readStream := original readStream.
	inComment := false.
	[readStream atEnd] whileFalse: [| ch |
		ch := readStream next.
		ch = $"
			ifTrue: [
				inComment := inComment not.
				readStream atEnd ifTrue: [ch := nil] ifFalse: [ch := readStream next]].
		(inComment or: [ch isNil]) ifFalse: [newStream nextPut: ch]].
	^newStream contents
]

{
	#category : 'parsing'
}
TonelParser >> separator [
	[ stream atEnd not and: [ self isSeparator: stream peek ] ]
		whileTrue: [ stream next ].
	^ nil
]

{
	#category : 'accessing'
}
TonelParser >> start [
	^ self document
]

{
	#category : 'accessing'
}
TonelParser >> stream: aStream [
	stream := aStream
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> try: aBlock [
	^ self
		try: aBlock
		onSuccess: [ :parsedValue | parsedValue ]
		onFailure: [ nil ]
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> try: aBlock onFailure: failureBlock [
	^ self
		try: aBlock
		onSuccess: [ :parsedValue | parsedValue ]
		onFailure: failureBlock
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> try: aBlock onSuccess: successBlock [
	^ self try: aBlock onSuccess: successBlock onFailure: [ nil ]
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> try: aBlock onSuccess: successBlock onFailure: failureBlock [
	| pos |
	pos := stream position.
	[ ^ successBlock value: aBlock value ]
		on: TonelParseError
		do: [ :e | 
			stream position: pos.
			^ failureBlock value ]
]

{
	#category : 'parsing'
}
TonelParser >> type [
	self try: [ self word: 'Class' ] onSuccess: [ :word | ^ word ].
	self try: [ self word: 'Extension' ] onSuccess: [ :word | ^ word ].
	self try: [ self word: 'Package' ] onSuccess: [ :word | ^ word ].

	"at end"
	TonelParseError signal: 'Can''t parse type.'
]

{
	#category : 'parsing'
}
TonelParser >> typeDef [
	^ self
		newTypeDefinitionFrom:
			((Array new: 6)
				at: 1 put: self separator;
				at: 2 put: (self try: [ self comment ]);
				at: 3 put: self separator;
				at: 4 put: self type;
				at: 5 put: self separator;
				at: 6 put: (self try: [ self metadata ]);
				yourself)
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> untilExcluding: aCollection [
	| result |
	result := stream upToAll: aCollection.
	stream position: stream position - aCollection size.
	^ result
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> untilIncluding: aCollection [
	^ stream upToAll: aCollection
]

{
	#category : 'private parsing',
	#vaVisibility : 'private'
}
TonelParser >> word: aString [
	| result |
	result := stream next: aString size.
	result = aString
		ifFalse: [ TonelParseError signal: 'Can''t parse ' , aString ].
	^ result
]
